<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>Refraktometer-Rechner</title>
    <link rel="icon" type="image/png" href="icon.png"/>    
    <meta name="description" content="Refraktometer Berechnungen und Messwertkorrektur für Hobbybrauer">
    <meta name="keywords" content="Refraktometer, Refraktometer-Korrektur, Bier, Brauen, Hobbybrauer">
    <meta name="author" content="Thomas Ascher">   
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="jquery.mobile-1.4.5.min.css">
    <script src="jquery-2.2.4.min.js"></script>
    <script src="jquery.mobile-1.4.5.min.js"></script>
    <script src="PolynomialRegression.js"></script>
</head>
<body>
<script>
// Copyright (c) 2021 Thomas Ascher
// SPDX-License-Identifier: MIT

function correctBx(bx, wcf) {
    return bx / wcf;
}

// Alcohol content estimation and Plato/SG conversion implemented according to:
// G. Spedding. "Alcohol and Its Measurement". In: Brewing Materials and Processes. Elsevier,
// 2016, S. 123-149. DOI: 10.1016/b978-0-12-799954-8.00007-1.

function sgToP(sg) {
    return sg**2 * -205.347 + 668.72 * sg - 463.37;
}

function pToSG(p) {
    return p / (258.6 - (p / 258.2 * 227.1)) + 1.0;
}

function calcRE(oe, ae) {
    return 0.1948 * oe + 0.8052 * ae;
}

function calcABW(oe, re) {
    return (oe - re) / (2.0665 - (1.0665 * oe / 100.0));
}

function calcABV(abw, fg) {
    return abw * fg / 0.7907;
}

// Degree of fermentation calculation implemented according to:
// Alex Speers. Brewing Calculations. 2015.
// URL: https://chme.nmsu.edu/files/2017/03/FeatAug15.pdf

function calcADF(oe, ae) {
    return (oe - ae) * 100.0 / oe;
}

function calcRDF(oe, re) {
    return ((oe - re) * 100.0 / oe) * (1 / (1 - 0.005161 * re));
}

// Bonham (Standard) correlation function implemented according to:
// Louis K. Bonham. "The Use of Handheld Refractometers by Homebrewers".
// In: Zymurgy 24.1 (2001), S. 43-46.

function corBonham(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    fg = 1.001843 - 0.002318474 * oe - 0.000007775 * oe**2 -
        0.000000034 * oe**3 + 0.00574 * bxf +
        0.00003344 * bxf**2 + 0.000000086 * bxf**3;
    return [oe, sgToP(fg), fg];
}

// Gardner correlation function implemented according to:
// Louis K. Bonham. "The Use of Handheld Refractometers by Homebrewers".
// In: Zymurgy 24.1 (2001), S. 43-46.

function corGardner(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    ae = 1.53 * bxf - 0.59 * oe;
    return [oe, ae, pToSG(ae)];
}

// Gossett correlation function implemented according to:
// James M. Gossett. Derivation and Explanation of the Brix-Based Calculator For Estimating
// ABV in Fermenting and Finished Beers. 2012.
// URL: http://www.ithacoin.com/brewing/Derivation.htm

function abwGosett(bxi, bxf, wcf) {
    k = 0.445;
    c = 100.0 * (bxi - bxf) / (100.0 - 48.4 * k - 0.582 * bxf);
    return 48.4 * c / (100 - 0.582 * c);
}

function corFromABW(abw, bxi, wcf) {
    oe = correctBx(bxi, wcf);
    ae = oe - (abw * (2.0665 - 1.0665 * oe / 100.0)) / 0.8052;
    return [oe, ae, pToSG(ae)];
}

// The Gossett correlation is for abw and not fg. For abv calculation Gossett utilizes the
// Bonham correlation. Here the fg is derived from the abw equation instead.
function corGossett(bxi, bxf, wcf) {
    return corFromABW(abwGosett(bxi, bxf, wcf), bxi, wcf);
}

// Novotný correlation functions implemented according to:
// Petr Novotný. Počítáme: Nová korekce refraktometru. 2017.
// URL: http://www.diversity.beer/2017/01/pocitame-nova-korekce-refraktometru.html

function corNovotnyLinear(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = -0.002349 * oe + 0.006276 * bxfc + 1.0;
    return [oe, sgToP(fg), fg];
}

function corNovotnyQuadratic(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = 1.335 * 10.0**-5 * oe**2 -
        3.239 * 10.0**-5 * oe * bxfc +
        2.916 * 10.0**-5 * bxfc**2 -
        2.421 * 10.0**-3 * oe +
        6.219 * 10.0**-3 * bxfc + 1.0;
    return [oe, sgToP(fg), fg];
}

// Terrill correlation functions implemented according to:
// Sean Terrill. Refractometer FG Results. 2011.
// URL: http://seanterrill.com/2011/04/07/refractometer-fg-results/

function corTerrillLinear(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = 1.0 - 0.000856829 * oe + 0.00349412 * bxfc;
    return [oe, sgToP(fg), fg];
}

function corTerrillCubic(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = 1.0 - 0.0044993 * oe + 0.000275806 * oe**2 -
        0.00000727999 * oe**3 + 0.0117741 * bxfc -
        0.00127169 * bxfc**2 + 0.0000632929 * bxfc**3;
    return [oe, sgToP(fg), fg];
}

// Nutrient content calculation implemented according to:
// Michael L. Hall. Brew by the Numbers.
// In: Zymurgy Summer 1995, S. 54-61.

function calcKcalPer100ML(og, fg) {
    return (3621.0 * fg * ((0.8114 * fg + 0.1886 * og - 1.0) + 0.53 * (og - fg) / (1.775 - og))) / 354.8812 * 100.0;
}

function kcalToKJ(kcal) {
    return kcal * 4.1858;
}

calibration = [
    {
        x : 0,
        y : 0
    },
    {
        x : 6,
        y : 7
    },
    {
        x : 14,
        y : 15
    }   
]; 

calibrationModel = PolynomialRegression.read(calibration, 2);
calibrationModelTerms = calibrationModel.getTerms();

class RefracModel {
    constructor(corModel, abwModel = null) {
        this.corModel = corModel;  
        this.abwModel = abwModel;
    }

    calc(bxi, bxf, wcf) {
        bxi = calibrationModel.predictY(calibrationModelTerms, bxi * 1.0);
        bxf = calibrationModel.predictY(calibrationModelTerms, bxf * 1.0);
        const [oe, ae, fg] = this.corModel(bxi, bxf, wcf);
        let result = new Result();
        result.oe = oe;
        result.ae = ae;
        result.fg = fg;
        result.re = calcRE(oe, ae);
        if (this.abwModel == null) {
            result.abw = calcABW(oe, result.re);
        } else {
            result.abw = this.abwModel(bxi, bxf, wcf);
        }
        result.abv = calcABV(result.abw, fg);
        result.adf = calcADF(oe, ae);
        result.rdf = calcRDF(oe, result.re);
        result.kcal = calcKcalPer100ML(pToSG(oe), fg);
        result.kj = kcalToKJ(result.kcal);
        return result;
    }
}

refracModels = [
    new RefracModel(corNovotnyLinear),
    new RefracModel(corNovotnyQuadratic),    
    new RefracModel(corTerrillLinear),
    new RefracModel(corTerrillCubic),
    new RefracModel(corBonham),
    new RefracModel(corGardner),
    new RefracModel(corGossett, abwGosett)       
];

class Result {
    constructor() {
        this.oe = NaN;
        this.ae = NaN;
        this.fg = NaN;
        this.re = NaN;
        this.abv = NaN;
        this.abw = NaN;
        this.adf = NaN;
        this.rdf = NaN;
        this.kcal = NaN;
        this.kj = NaN;
    }
}

function isNumeric(str) {
    if (typeof str != "string")
        return false;  
    return !isNaN(str) && !isNaN(parseFloat(str))
}

function isValidInput(value) {
    return isNumeric(value) && parseFloat(value) > 0.0;
}

class Input {
    constructor() {
        this.modelIndex = 0;
        this.bxi = "";
        this.bxf = "";
        this.wcf = "";
    }

    hasBXI() {
        return isValidInput(this.bxi);
    }

    hasBXF() {
        return isValidInput(this.bxf);
    }

    hasWCF() {
        return isValidInput(this.wcf);
    }
}

function calc(input) {
    var result = new Result();
    if (input.hasBXI() && input.hasWCF()) {
        model = refracModels[input.modelIndex];
        result.oe = correctBx(input.bxi, input.wcf);
        if (input.hasBXF() && parseFloat(input.bxi) > parseFloat(input.bxf)) {
            result = model.calc(input.bxi, input.bxf, input.wcf);
        }
    };
    return result;
}

function textify(value, unit, digits = 2) {
    if (isNaN(value)) {
        return "-";
    } else {
        return value.toFixed(digits) + " " + unit;
    }
}

function concat(text1, text2) {
    return text1 + " / " + text2;
}

function textify2(value1, unit1, value2, unit2) {
    return concat(textify(value1, unit1), textify(value2, unit2));
}

function textifyExtract(value1, value2 = NaN) {
    if (isNaN(value2))
        value2 = pToSG(value1);
    return concat(textify(value1, "°P"), textify(value2, "SG", 3));
}

function updateTable(result) {
    $('#abvoutput').html(textify2(result.abv, "vol %", result.abw, "%"));            
    $('#oeoutput').html(textifyExtract(result.oe));
    $('#aeoutput').html(textifyExtract(result.ae, result.fg));
    $('#adfoutput').html(textify(result.adf, "%"));            
    $('#reoutput').html(textifyExtract(result.re));
    $('#rdfoutput').html(textify(result.rdf, "%"));
    $('#caloutput').html(textify2(result.kj, "kJ", result.kcal, "kcal"));
}

function getInput() {
    var input = new Input();
    input.modelIndex = $('#formselect').prop('selectedIndex');
    input.bxi = $('#bxiinput').val();
    input.bxf = $('#bxfinput').val();
    input.wcf = $('#wcfinput').val();
    return input;
}

function setInput(input) {
    $('#formselect').prop('selectedIndex', input.modelIndex).change();
    $('#bxiinput').val(input.bxi);
    $('#bxfinput').val(input.bxf);
    $('#wcfinput').val(input.wcf);
}

const STORAGE_NAME = "lastInput";

function storeInput() {
    var input = getInput();
    localStorage.setItem(STORAGE_NAME, JSON.stringify(input));
}

function restoreInput() {
    try {
        var item = localStorage.getItem(STORAGE_NAME);
        if (!(item === null)) {
            var input = JSON.parse(item);
            setInput(input);
            updateResult();
        }
    } catch (err) {
    }
}

function updateResult() {
    var input = getInput();
    var result = calc(input);
    updateTable(result);
}

$(document).ready(function() {
    $('#btncalc').click(function() {
        updateResult();
        storeInput();
    });
    updateTable(new Result());
    restoreInput();
});
</script>
<div data-role="page" id="calculation">
    <div data-role="header">
        <h1>Refraktometer-Rechner</h1>
        <a href="#calibration" data-role="button" data-icon="gear" class="ui-btn-right">Kalibrierung</a>
    </div>
    <div role="main" class="ui-content">
        <form>
            <label for="formselect">Korrelationsmodell:</label>
            <select name="formselect" id="formselect">
                <option value="0">Novotný Linear</option>
                <option value="1">Novotný Quadratisch</option>                
                <option value="2">Terrill Linear</option>
                <option value="3">Terrill Kubisch</option>
                <option value="4">Bonham (Stan­dard)</option>
                <option value="5">Gardner</option>
                <option value="6">Gossett</option>
            </select>
            <label for="bxiinput">Refraktometerwert Stammwürze (°Bx):</label>
            <input type="number" name="bxiinput" id="bxiinput" value="" step="0.1" />
            <label for="bxfinput">Refraktometerwert Jungbier (°Bx):</label>
            <input type="number" name="bxfinput" id="bxfinput" value="" step="0.1" />
            <label for="wcfinput">Würze-Korrekturfaktor:</label>
            <input type="number" name="wcfinput" id="wcfinput" value="1.04" step="0.01" />
        </form>
        <button name="btncalc" id="btncalc">Berechnen</button>
        <table>
            <tbody>
                <tr>
                    <td>Alkoholgehalt:</td>
                    <td id="abvoutput"></td>
                </tr>
                <tr>
                    <td>Stammwürze:</td>
                    <td id="oeoutput"></td>
                </tr>
                <tr>
                    <td>Scheinbarer Restextrakt:</td>
                    <td id="aeoutput"></td>
                </tr>
                <tr>
                    <td>Scheinbarer Vergärungsgrad:</td>
                    <td id="adfoutput"></td>
                </tr>
                <tr>
                    <td>Wirklicher Restextrakt:</td>
                    <td id="reoutput"></td>
                </tr>
                <tr>
                    <td>Wirklicher Vergärungsgrad:</td>
                    <td id="rdfoutput"></td>
                </tr>
                <tr>
                    <td>Nährwert je 100 ml:</td>
                    <td id="caloutput"></td>
                </tr>                                                                  
            </tbody>
        </table>
    </div>
</div>
<div data-role="page" id="calibration">
    <div data-role="header">
        <a href="#calculation" data-role="button" data-icon="back">Zurück</a>        
        <h1>Refraktometer-Rechner: Kalibrierung</h1>
        <div class="ui-btn-right">
            <a href="#calculation" data-role="button" data-icon="plus">Hinzufügen</a>        
            <a href="#calculation" data-role="button" data-icon="check">Speichern</a>
        </div>
    </div>
    <div role="main" class="ui-content">

    </div>
</div>
</body>
</html>
