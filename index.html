<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <title>Refraktometer-Rechner</title>
    <link rel="icon" type="image/png" href="icon.png"/>    
    <meta name="description" content="Refraktometer Berechnungen und Messwertkorrektur für Hobbybrauer">
    <meta name="keywords" content="Refraktometer, Refraktometer-Korrektur, Bier, Brauen, Hobbybrauer">
    <meta name="author" content="Thomas Ascher">   
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="jquery.mobile-1.4.5.min.css">
    <script src="jquery-2.2.4.min.js"></script>
    <script src="jquery.mobile-1.4.5.min.js"></script>
    <script src="PolynomialRegression.js"></script>
</head>
<body>
<script>
// Copyright (c) 2021 Thomas Ascher
// SPDX-License-Identifier: MIT

function correctBx(bx, wcf) {
    return bx / wcf;
}

// Alcohol content estimation and Plato/SG conversion implemented according to:
// G. Spedding. "Alcohol and Its Measurement". In: Brewing Materials and Processes. Elsevier,
// 2016, S. 123-149. DOI: 10.1016/b978-0-12-799954-8.00007-1.

function sgToP(sg) {
    return sg**2 * -205.347 + 668.72 * sg - 463.37;
}

function pToSG(p) {
    return p / (258.6 - (p / 258.2 * 227.1)) + 1.0;
}

function calcRE(oe, ae) {
    return 0.1948 * oe + 0.8052 * ae;
}

function calcABW(oe, re) {
    return (oe - re) / (2.0665 - (1.0665 * oe / 100.0));
}

function calcABV(abw, fg) {
    return abw * fg / 0.7907;
}

// Degree of fermentation calculation implemented according to:
// Alex Speers. Brewing Calculations. 2015.
// URL: https://chme.nmsu.edu/files/2017/03/FeatAug15.pdf

function calcADF(oe, ae) {
    return (oe - ae) * 100.0 / oe;
}

function calcRDF(oe, re) {
    return ((oe - re) * 100.0 / oe) * (1 / (1 - 0.005161 * re));
}

// Bonham (Standard) correlation function implemented according to:
// Louis K. Bonham. "The Use of Handheld Refractometers by Homebrewers".
// In: Zymurgy 24.1 (2001), S. 43-46.

function corBonham(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    fg = 1.001843 - 0.002318474 * oe - 0.000007775 * oe**2 -
        0.000000034 * oe**3 + 0.00574 * bxf +
        0.00003344 * bxf**2 + 0.000000086 * bxf**3;
    return [oe, sgToP(fg), fg];
}

// Gardner correlation function implemented according to:
// Louis K. Bonham. "The Use of Handheld Refractometers by Homebrewers".
// In: Zymurgy 24.1 (2001), S. 43-46.

function corGardner(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    ae = 1.53 * bxf - 0.59 * oe;
    return [oe, ae, pToSG(ae)];
}

function abwGardner(bxi, bxf, wcf) {
    const [oe, ae, fg] = corGardner(bxi, bxf, wcf);
    return 1.09 * bxf - 1.13 * ae;
}

// Gossett correlation function implemented according to:
// James M. Gossett. Derivation and Explanation of the Brix-Based Calculator For Estimating
// ABV in Fermenting and Finished Beers. 2012.
// URL: http://www.ithacoin.com/brewing/Derivation.htm

function abwGosett(bxi, bxf, wcf) {
    k = 0.445;
    c = 100.0 * (bxi - bxf) / (100.0 - 48.4 * k - 0.582 * bxf);
    return 48.4 * c / (100 - 0.582 * c);
}

function corFromABW(abw, bxi, wcf) {
    oe = correctBx(bxi, wcf);
    ae = oe - (abw * (2.0665 - 1.0665 * oe / 100.0)) / 0.8052;
    return [oe, ae, pToSG(ae)];
}

// The Gossett correlation is for abw and not fg. For abv calculation Gossett utilizes the
// Bonham correlation. Here the fg is derived from the abw equation instead.
function corGossett(bxi, bxf, wcf) {
    return corFromABW(abwGosett(bxi, bxf, wcf), bxi, wcf);
}

// Novotný correlation functions implemented according to:
// Petr Novotný. Počítáme: Nová korekce refraktometru. 2017.
// URL: http://www.diversity.beer/2017/01/pocitame-nova-korekce-refraktometru.html

function corNovotnyLinear(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = -0.002349 * oe + 0.006276 * bxfc + 1.0;
    return [oe, sgToP(fg), fg];
}

function corNovotnyQuadratic(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = 1.335 * 10.0**-5 * oe**2 -
        3.239 * 10.0**-5 * oe * bxfc +
        2.916 * 10.0**-5 * bxfc**2 -
        2.421 * 10.0**-3 * oe +
        6.219 * 10.0**-3 * bxfc + 1.0;
    return [oe, sgToP(fg), fg];
}

// Terrill correlation functions implemented according to:
// Sean Terrill. Refractometer FG Results. 2011.
// URL: http://seanterrill.com/2011/04/07/refractometer-fg-results/

function corTerrillLinear(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = 1.0 - 0.000856829 * oe + 0.00349412 * bxfc;
    return [oe, sgToP(fg), fg];
}

function corTerrillCubic(bxi, bxf, wcf) {
    oe = correctBx(bxi, wcf);
    bxfc = correctBx(bxf, wcf);
    fg = 1.0 - 0.0044993 * oe + 0.000275806 * oe**2 -
        0.00000727999 * oe**3 + 0.0117741 * bxfc -
        0.00127169 * bxfc**2 + 0.0000632929 * bxfc**3;
    return [oe, sgToP(fg), fg];
}

// Sean Terrill's website issues. 2020.
// URL: https://www.reddit.com/r/Homebrewing/comments/bs3af9/sean_terrills_website_issues

function corNovotrill(bxi, bxf, wcf) {
    const [oe1, ae1, fg1] = corTerrillLinear(bxi, bxf, wcf);
    const [oe2, ae2, fg2] = corNovotnyLinear(bxi, bxf, wcf);
    fg_mean = (fg1 + fg2) / 2.0;
    fg = fg1;
    if (fg_mean < 1.014)
        fg = fg1;
    else
        fg = fg2;
    return [oe1, sgToP(fg), fg];
}

// Nutrient content calculation implemented according to:
// MEBAK. Wort, Beer and Beer-based Beverages. Freising-Weihenstephan: Fritz Jacob, 2013,
// S. 161. ISBN: 978-3-9805814-7-9.

function calcKJPer100ML(fg, re, abw) {
    return fg * (14 * re + 29 * abw);
}

function calcKcalPer100ML(fg, re, abw) {
    return fg * (3.5 * re + 7 * abw);
}

calibrationData = [
]; 

selectedMeasurement = -1;

function initCalibration() {
    calibration = new Calibration(calibrationData);
}

function createTuple(target, actual) {
    return { x: actual, y: target };
}

class Calibration {
    constructor(data) {
        let dataWithZero = [...data];
        dataWithZero.push(createTuple(0.0, 0.0));
        if (dataWithZero.length > 1) {
            let degree = dataWithZero.length - 1;
            if (degree > 3)
                degree = 3;
            this.model = PolynomialRegression.read(dataWithZero, degree);
            this.terms = this.model.getTerms();
        } else {
            this.model = null;
            this.terms = null;
        }
    }

    getType() {
        if (this.model == null) {
            return "1-Punkt"
        } else if (this.model.degree == 1) {
            return "2-Punkt";
        } else {
            return "N-Punkt";
        }
    }

    transform(value) {
        let newValue = value;
        if (this.model != null) {
            newValue = this.model.predictY(this.terms, newValue);
        }
        return newValue;
    }
}

initCalibration();

class RefracModel {
    constructor(corModel, abwModel = null) {
        this.corModel = corModel;  
        this.abwModel = abwModel;
    }

    calc(bxi_, bxf_, wcf) {
        let bxi = calibration.transform(bxi_);
        let bxf = calibration.transform(bxf_);
        const [oe, ae, fg] = this.corModel(bxi, bxf, wcf);
        let result = new Result();
        result.oe = oe;
        result.ae = ae;
        result.fg = fg;
        result.re = calcRE(oe, ae);
        if (this.abwModel == null) {
            result.abw = calcABW(oe, result.re);
        } else {
            result.abw = this.abwModel(bxi, bxf, wcf);
        }
        result.abv = calcABV(result.abw, fg);
        result.adf = calcADF(oe, ae);
        result.rdf = calcRDF(oe, result.re);
        result.kcal = calcKcalPer100ML(fg, result.re, result.abw);
        result.kj = calcKJPer100ML(fg, result.re, result.abw);
        return result;
    }
}

refracModels = [
    new RefracModel(corTerrillLinear),
    new RefracModel(corTerrillCubic),
    new RefracModel(corNovotnyLinear),
    new RefracModel(corNovotnyQuadratic),
    new RefracModel(corNovotrill),
    new RefracModel(corBonham),
    new RefracModel(corGardner /*, abwGardner*/),
    new RefracModel(corGossett, abwGosett)       
];

class Result {
    constructor() {
        this.oe = NaN;
        this.ae = NaN;
        this.fg = NaN;
        this.re = NaN;
        this.abv = NaN;
        this.abw = NaN;
        this.adf = NaN;
        this.rdf = NaN;
        this.kcal = NaN;
        this.kj = NaN;
    }
}

function isNumeric(str) {
    if (typeof str != 'string')
        return false;  
    return !isNaN(str) && !isNaN(parseFloat(str))
}

function isValidInput(value) {
    return isNumeric(value) && parseFloat(value) > 0.0;
}

class Input {
    constructor() {
        this.modelIndex = 0;
        this.bxi = '';
        this.bxf = '';
        this.wcf = '';
    }

    hasBXI() {
        return isValidInput(this.bxi);
    }

    getBXI() {
        return parseFloat(this.bxi);
    }

    hasBXF() {
        return isValidInput(this.bxf);
    }

    getBXF() {
        return parseFloat(this.bxf);
    }

    hasWCF() {
        return isValidInput(this.wcf);
    }

    getWCF() {
        return parseFloat(this.wcf);
    }
}

function calc(input) {
    var result = new Result();
    if (input.hasBXI() && input.hasWCF()) {
        model = refracModels[input.modelIndex];
        result.oe = correctBx(calibration.transform(input.getBXI()), input.getWCF());
        if (input.hasBXF() && input.getBXI() > input.getBXF()) {
            result = model.calc(input.getBXI(), input.getBXF(), input.getWCF());
        }
    };
    return result;
}

function textify(value, unit, digits = 2) {
    if (isNaN(value)) {
        return "-";
    } else {
        return parseFloat(value.toFixed(digits)).toLocaleString() + " " + unit;
    }
}

function concat(text1, text2) {
    return text1 + "; " + text2;
}

function textify2(value1, unit1, value2, unit2) {
    return concat(textify(value1, unit1), textify(value2, unit2));
}

function updateTable(result) {
    $('#abvoutput').html(textify2(result.abv, "vol %", result.abw, "%"));            
    $('#oeoutput').html(textify(result.oe, "°P"));
    $('#aeoutput').html(textify(result.ae, "g/100g"));
    $('#adfoutput').html(textify(result.adf, "%"));            
    $('#reoutput').html(textify(result.re, "g/100g"));
    $('#rdfoutput').html(textify(result.rdf, "%"));
    $('#caloutput').html(textify2(result.kj, "kJ", result.kcal, "kcal"));
    $('#caliboutput').html(calibration.getType());
}

function getInput() {
    var input = new Input();
    input.modelIndex = $('#formselect').prop('selectedIndex');
    input.bxi = $('#bxiinput').val();
    input.bxf = $('#bxfinput').val();
    input.wcf = $('#wcfinput').val();
    return input;
}

function setInput(input) {
    $('#formselect').prop('selectedIndex', input.modelIndex).change();
    $('#bxiinput').val(input.bxi);
    $('#bxfinput').val(input.bxf);
    $('#wcfinput').val(input.wcf);
}

const STORAGE_NAME_INPUT = 'lastInput';
const STORAGE_NAME_CALIB = 'calibrationData';

function storeInput() {
    var input = getInput();
    localStorage.setItem(STORAGE_NAME_INPUT, JSON.stringify(input));
}

function restoreInput() {
    try {
        var item = localStorage.getItem(STORAGE_NAME_INPUT);
        if (!(item === null)) {
            var input = JSON.parse(item);
            setInput(input);
            updateResult();
        }
    } catch (err) {
    }
}

function storeCalibration() {
    localStorage.setItem(STORAGE_NAME_CALIB, JSON.stringify(calibrationData));
}

function restoreCalibration() {
    try {
        var item = localStorage.getItem(STORAGE_NAME_CALIB);
        if (!(item === null)) {
            calibrationData = JSON.parse(item);
        }
    } catch (err) {
        calibrationData = []
    }
    initCalibration();
}

function updateResult() {
    var input = getInput();
    var result = calc(input);
    updateTable(result);
}

function initList() {
    clearListView('#lvcalibration');
    addItemsToList('#lvcalibration', calibrationData, function(i, entity) {
    	text = concat('Sollwert: ' + textify(entity.y, '°Bx'), 'Istwert: ' + textify(entity.x, '°Bx'));
        return '<li id="' + i + '"><a href="#pdetails">' + text + '</a></li>';
    });
}

function clearListView(listviewId) {
    $(listviewId).empty();
    refreshListView(listviewId);
}

function refreshListView(listviewId) {
    $(listviewId).listview('refresh');
}

function addItemsToList(listviewId, items, itemRenderer) {
    $.each(items, function(i, item) {
    	itemCode = itemRenderer(i, item);
    	$(listviewId).append(itemCode);
    });
    refreshListView(listviewId);
}

function showButton(buttonId, shouldShow) {
    var button = $(buttonId);
    if (shouldShow)
        button.show();
    else
        button.hide();
}

$(document).on('pageinit', '#pcalculation', function(event) {
    $('#btncalc').click(function() {
        updateResult();
        storeInput();
    });
    updateTable(new Result());
    restoreCalibration();
    restoreInput();
});

$(document).on('pageinit', '#pcalibration', function(event) {
    initList();
    $('#lvcalibration').delegate('li', 'click', function() {
		selectedMeasurement = $(this).attr('id');
        entry = calibrationData[selectedMeasurement];
        $('#targetinput').val(entry.y);
        $('#actualinput').val(entry.x);
        showButton('#btndelete', true);
	});
	$('#btnadd').click(function() {
        selectedMeasurement = -1;
        $('#targetinput').val('');
        $('#actualinput').val('');
        showButton('#btndelete', false);
	});
});

function updateAfterCalibrationDataChange() {
    selectedMeasurement = -1;
    storeCalibration();
    initCalibration();
    initList();
    updateResult();
}

$(document).on('pageinit', '#pdetails', function(event) {
    $('#btnsave').click(function() {
        if (isValidInput($('#targetinput').val()) && isValidInput($('#actualinput').val())) {
            target = parseFloat($('#targetinput').val())
            actual = parseFloat($('#actualinput').val())
            entry = createTuple(target, actual);
            if (selectedMeasurement >= 0)
                calibrationData[selectedMeasurement] = entry
            else
                calibrationData.push(entry);
        }
        updateAfterCalibrationDataChange();
    });
    $('#btndelete').click(function() {
        calibrationData.splice(selectedMeasurement, 1);
        updateAfterCalibrationDataChange();
    });
});

</script>
<div data-role="page" id="pcalculation">
    <div data-role="header">
        <h1>Refraktometer-Rechner</h1>
        <a href="#pcalibration" data-role="button" data-icon="gear" class="ui-btn-right">Kalibrierung</a>
    </div>
    <div role="main" class="ui-content">
        <form>
            <label for="formselect">Korrelationsmodell:</label>
            <select name="formselect" id="formselect">
                <option value="0">Terrill Linear</option>
                <option value="1">Terrill Kubisch</option>
                <option value="2">Novotný Linear</option>
                <option value="3">Novotný Quadratisch</option>
                <option value="4">Terrill+Novotný</option>
                <option value="5">Bonham (Stan­dard)</option>
                <option value="6">Gardner</option>
                <option value="7">Gossett</option>
            </select>
            <label for="bxiinput">Refraktometerwert Stammwürze (°Bx):</label>
            <input type="number" name="bxiinput" id="bxiinput" value="" step="0.1" />
            <label for="bxfinput">Refraktometerwert Jungbier (°Bx):</label>
            <input type="number" name="bxfinput" id="bxfinput" value="" step="0.1" />
            <label for="wcfinput">Würze-Korrekturfaktor:</label>
            <input type="number" name="wcfinput" id="wcfinput" value="1.04" step="0.01" />
        </form>
        <button name="btncalc" id="btncalc">Berechnen</button>
        <table>
            <tbody>
                <tr>
                    <td>Alkoholgehalt:</td>
                    <td id="abvoutput"></td>
                </tr>
                <tr>
                    <td>Stammwürze:</td>
                    <td id="oeoutput"></td>
                </tr>
                <tr>
                    <td>Scheinbarer Restextrakt:</td>
                    <td id="aeoutput"></td>
                </tr>
                <tr>
                    <td>Scheinbarer Vergärungsgrad:</td>
                    <td id="adfoutput"></td>
                </tr>
                <tr>
                    <td>Wirklicher Restextrakt:</td>
                    <td id="reoutput"></td>
                </tr>
                <tr>
                    <td>Wirklicher Vergärungsgrad:</td>
                    <td id="rdfoutput"></td>
                </tr>
                <tr>
                    <td>Nährwert je 100 ml:</td>
                    <td id="caloutput"></td>
                </tr>
                <tr>
                    <td>Kalibrierung:</td>
                    <td id="caliboutput"></td>
                </tr>                                                                               
            </tbody>
        </table>
    </div>
</div>
<div data-role="page" id="pcalibration">
    <div data-role="header">
        <a href="#pcalculation" data-role="button" data-icon="back">Zurück</a>        
        <h1>Kalibrierung</h1>
        <a href="#pdetails" data-role="button" data-icon="plus" name="btnadd" id="btnadd">Hinzufügen</a>
    </div>
    <div role="main" class="ui-content">
        <ul data-role="listview" id="lvcalibration">
        </ul>
    </div>
</div>
<div data-role="page" id="pdetails">
    <div data-role="header">
        <a href="#pcalibration" data-role="button" data-icon="back">Zurück</a>        
        <h1>Messpunkt</h1>
    </div>
    <div role="main" class="ui-content">
        <form>
            <label for="targetinput">Sollwert (°Bx):</label>
            <input type="number" name="targetinput" id="targetinput" value="" step="0.1" />
            <label for="actualinput">Istwert (°Bx):</label>
            <input type="number" name="actualinput" id="actualinput" value="" step="0.1" />
        </form>
    </div>
    <div data-role="footer">
        <a href="#pcalibration" data-role="button" data-icon="delete" name="btndelete" id="btndelete" class="ui-btn-left">Löschen</a>
        <a href="#pcalibration" data-role="button" data-icon="check" name="btnsave" id="btnsave" class="ui-btn-right">Speichern</a>
    </div>	
</div>
</body>
</html>
